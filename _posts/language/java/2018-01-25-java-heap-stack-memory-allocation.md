---
layout: post
title: java 中堆内存和栈内存详解
category: 语言
tags: java jvm
keywords: java jvm memory
description:
---

Java 把内存分成两种，一种叫做栈内存，一种叫做堆内存.

### 栈内存

在函数中定义的一些 **基本类型** 的变量和 **对象的引用变量** 都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，java 会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

### 堆内存

堆内存用于存放由 **new** 创建的对象和数组。在堆中分配的内存，由 java 虚拟机 **自动垃圾回收器** 来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用 new 产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，**数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉**。这个也是 java 比较占内存的主要原因，实际上，**栈中的变量指向堆内存中的变量** ，这就是 Java 中的指针!

## java 中内存分配策略及堆和栈的比较 

### 内存分配策略 

按照编译原理的观点, 程序运行时的内存分配有三种策略, 分别是静态的, 栈式的, 和堆式的.

* 静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求, 因而在编译时就可以给他们分配固定的内存空间. 这种分配策略要求程序代码中不允许有可变数据结构 (比如可变数组) 的存在, 也不允许有嵌套或者递归的结构出现, 因为它们都会导致编译程序无法计算准确的存储空间需求. 

* 栈式存储分配也可称为动态存储分配, 是由一个类似于堆栈的运行栈来实现的. 和静态存储分配相反, 在栈式存储方案中, 程序对数据区的需求在编译时是完全未知的, 只有到运行的时候才能够知道, 但是规定在运行中进入一个程序模块时, 必须知道该程序模块所需的数据区大小才能够为其分配内存. 和我们在数据结构所熟知的栈一样, 栈式存储分配按照先进后出的原则进行分配。 

* 静态存储分配要求在编译时能知道所有变量的存储要求, 栈式存储分配要求在过程的入口处必须知道所有的存储要求, 而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配, 比如可变长度串和对象实例. 堆由大片的可利用块或空闲块组成, 堆中的内存可以按照任意顺序分配和释放. 

### 堆和栈的比较 

上面的定义从编译原理的教材中总结而来, 除静态存储分配之外, 都显得很呆板和难以理解, 下面撇开静态存储分配, 集中比较堆和栈: 

从堆和栈的功能和作用来通俗的比较, 堆主要用来存放对象的，栈主要是用来执行程序的. 而这种不同又主要是由于堆和栈的特点决定的: 

在编程中，例如 C/C++ 中，所有的方法调用都是通过栈来进行的, 所有的局部变量, 形式参数都是从栈中分配内存空间的。实际上也不是什么分配, 只是从栈顶向上用就行, 就好像工厂中的传送带 (conveyor belt) 一样, Stack Pointer 会自动指引你到放东西的位置, 你所要做的只是把东西放下来就行. 退出函数的时候，修改栈指针就可以把栈中的内容销毁. 这样的模式速度最快, 当然要用来运行程序了. 需要注意的是, 在分配的时候, 比如为一个即将要调用的程序模块分配数据区时, 应事先知道这个数据区的大小, 也就说是虽然分配是在程序运行时进行的, 但是分配的大小多少是确定的, 不变的, 而这个 "大小多少" 是在编译时确定的, 不是在运行时. 

堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配, 所以在分配和销毁时都要占用时间，因此用堆的效率非常低. 但是堆的优点在于, 编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间, 因此, 用堆保存数据时会得到更大的灵活性。事实上, 面向对象的多态性, 堆内存分配是必不可少的, 因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定. 在 C++ 中，要求创建一个对象时，只需用 new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存. 当然，为达到这种灵活性，必然会付出一定的代价: 在堆里分配存储空间时会花掉更长的时间! 这也正是导致我们刚才所说的效率低的原因。

### JVM 中的堆和栈

JVM 是基于堆栈的虚拟机. JVM 为每个新创建的线程都分配一个堆栈. 也就是说, 对于一个 Java 程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM 对堆栈只进行两种操作: 以帧为单位的压栈和出栈操作。 

我们知道, 某个线程正在执行的方法称为此线程的当前方法. 我们可能不知道, 当前方法使用的帧称为当前帧。当线程激活一个 Java 方法, JVM 就会在线程的 Java 堆栈里新压入一个帧。这个帧自然成为了当前帧. 在此方法执行期间, 这个帧将用来保存参数, 局部变量, 中间计算过程和其他数据. 这个帧在这里和编译原理中的活动纪录的概念是差不多的. 

从 Java 的这种分配机制来看, 堆栈又可以这样理解: 堆栈 (Stack) 是操作系统在建立某个进程时或者线程 (在支持多线程的操作系统中是线程) 为这个线程建立的存储区域，该区域具有先进后出的特性。 

每一个 Java 应用都唯一对应一个 JVM 实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中, 并由应用所有的线程共享. 跟 C/C++ 不同，**Java 中分配堆内存是自动初始化的。Java 中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配, 也就是说在建立一个对象时从两个地方都分配内存**，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针 (引用) 而已。

## 总结

栈与堆都是 Java 用来在 Ram 中存放数据的地方。与 C++ 不同，Java 自动管理栈和堆，程序员不能直接地设置栈或堆。 

Java 的堆是一个运行时数据区, 类的 (对象从中分配空间。这些对象通过 new、newarray、anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java 的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 

栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量 (,int, short, long, byte, float, double, boolean, char) 和对象句柄。 


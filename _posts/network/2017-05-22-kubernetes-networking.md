---
layout: post
title: Kubernetes 网络模型
category: 网络
tags: Kubernetes 网络
keywords: Kubernetes
description:
---

## Docker网络基础

### Linux网络名词解释： 

* 网络的命名空间：Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；__docker利用这一特性，实现不容器间的网络隔离。__

* Veth设备对：Veth设备对的引入是为了实现在不同网络命名空间的通信。

* Iptables/Netfilter：Netfilter负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核模式中；Iptables模式是在用户模式下运行的进程，负责协助维护内核中Netfilter的各种规则表；通过二者的配合来实现整个Linux网络协议栈中灵活的数据包处理机制。

* 网桥：网桥是一个二层网络设备,通过网桥可以将linux支持的不同的端口连接起来,并实现类似交换机那样的多对多的通信。

* 路由：Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。

### Docker网络实现

单机网络模式：Bridge 、Host、Container、None，这里具体就不赘述了
多机网络模式：一类是 Docker 在 1.9 版本中引入Libnetwork项目，对跨节点网络的原生支持；一类是通过插件（plugin）方式引入的第三方实现方案，比如 Flannel，Calico 等等

## Kubernetes 网络模型

在 Kubernetes 网络中存在两种IP（Pod IP 和 Service Cluster IP），Pod IP 地址是实际存在于某个网卡(可以是虚拟设备)上的，Service Cluster IP它是一个虚拟IP，是由 kube-proxy 使用 Iptables 规则重新定向到其本地端口，再均衡到后端 Pod 的。下面讲讲 Kubernetes Pod 网络设计模型：

1. 基本原则：    
每个Pod都拥有一个独立的IP地址（IP per Pod），而且假定所有的pod都在一个可以直接连通的、扁平的网络空间中。

2. 设计原因：
用户不需要额外考虑如何建立Pod之间的连接，也不需要考虑将容器端口映射到主机端口等问题。

3. 网络要求： 
所有的容器都可以在不用NAT的方式下同别的容器通讯；所有节点都可在不用NAT的方式下同所有容器通讯；容器的地址和别人看到的地址是同一个地址。

Kubernetes 网络需要解决下面四类不同的问题：

* 高耦合容器和容器间通信
* Pod 和 Pod 间通信
* Pod 和 Service 间通信
* 外部和内部通信

## 模型和动机

Kubernetes 从默认的 Docker 网络模型中脱离出来（Docker 1.8 的网络插件已经很接近）。在一个共享网络命名空间的平面内，目标是一个 pod 一个 IP，每个 pod 都可以和其它物理机或者容器实现跨网络通信。每个 pod 一个 IP 创建了一个简洁的，后向兼容的模型，在这个模型里，包括端口分配，组网，命名，服务发现，负载均衡，应用配置和迁移，pod 都可以被当作虚拟机或者物理主机。

另一方面，动态端口分配，要求同时支持静态端口（如对外部可接入的服务）和动态分配的端口；需要对中心型分配和本地获取动态端口做区分，复杂的调度（应为端口是稀缺资源）对用户来说是非常不方便的；复杂的应用配置，造成用户会被端口冲突、重用和耗尽所困扰；要求非标准的方式来命名（如 consul 和 etcd 而不是 DNS）；需要代理或者重定向才能让程序使用标准的命名和寻址技术（如 web 浏览器）；如果还希望监控整个组成员的变化，并且阻碍容器或 pod 迁移（使用 CRIU），就需要监控和缓存无效的地址和端口变化。其它问题中，NAT 分隔地址空间引入了额外的复杂度，打破了自注册机制。

## 容器到容器

所有容器在一个 pod 中表现为它们在同一个主机上并且不受网络限制。它们可以通过端口在本地实现互相通信。这提供了简单（已知静态端口），安全（端口绑定在 localhost，可以被 pod 中其他容器发现但不会被外部看到），还有性能提升。这同样减少了物理机或虚拟机上非容器化应用的迁移。人们运行应用都堆砌到统一个主机上，它已经解决了如何让端口不冲突和已经安排了如何让客户端去找到它。

这个方法确实减少了一个 pod 中容器的隔离性（端口可能冲突），并且可以没有容器私有化端口，但这些看起来都是未来才会面对的相对比较小的问题。另外，本地化 pod 是容器在 pod 中共享同样的资源（如 volumes，cpu，内存等），所以希望并且可以容忍隔离性的减少。通常情况，用户可以控制哪些容器属于同一个 pod，而不能控制哪些 pod 一起运行在一个主机上。

## Pod 到 Pod

因为每个 pod 都有一个 “真”（非机器私有的）的 IP 地址，pods 间可以相互通信，不依赖于代理和转换。Pod 可以使用一个常见的端口号，还可以防止更高层次的服务发现系统像 DNS-SD，Consul 或者 Etcd。

当任何容器调用 ioctl（SIOCGIFADDR）（获取接口的地址），可以看到相同的 IP，任何同级别的容器都可以看到这个 IP，就是说每一个 pod 有自己的 IP 地址，并且这个 IP 地址其他 pods 也可以知道。在容器内外通过生成相同 IP 地址和端口，我们创造了一个非 NAT 模式，扁平化的地址空间。运行ip addr show应该可以看到期待的值。这会让所有现在的命名或发现机制到盒子外面去实现，包括自注册机制和应用分发 IP 地址。我们应该对 pod 间网络通信持乐观态度。在一个 pod 内，容器间更像是通过 volumes（如 tmpfs）或者 IPC 来通信。

这种方式和标准的 Docker 模式有所不同。在 Docker 模式下，每一个容器有一个 IP，IP 是在 172.x.x.x 的网段内，并且只能从 SIOCGIFADDR 看到 172.x.x.x 的地址。如果这些容器连接了另一个容器，那同级别容器会看到这个连接来自于一个不同的 IP 而不是容器自己知道的 IP。简而言之，永远不能自注册同一个容器内的任何东西，因为一个容器不能被自己私有的 IP 获取到。

另一个解决方案我们考虑增加一个寻址层：每个容器一个中心化 pod 的 IP。每个容器有自己本地的 IP 地址，这个 IP 只在 pod 内可见。这种方案可能会让在物理机或虚拟机上的容器化应用移动到 pod 中更容易，但会使实现变得更复杂（如需要每个 pod 一个桥，水平分割的 DNS）。造成额外的地址转换，而且会破话自注册和 IP 分配机制。

像 Docker，端口仍可以向主机节点的接口公开，但这样的需求应该从根本上减少。
